// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"main/ent"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Coffee struct {
		Coffee       func(childComplexity int) int
		CoffeeMate   func(childComplexity int) int
		ID           func(childComplexity int) int
		Milk         func(childComplexity int) int
		PowderedMilk func(childComplexity int) int
		Rating       func(childComplexity int) int
		Sugar        func(childComplexity int) int
		Water        func(childComplexity int) int
	}

	CoffeeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CoffeeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateCoffee func(childComplexity int, input ent.CreateCoffeeInput) int
		DeleteCoffee func(childComplexity int, id int) int
		UpdateCoffee func(childComplexity int, id int, input ent.UpdateCoffeeInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Coffees func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int) int
		Node    func(childComplexity int, id int) int
		Nodes   func(childComplexity int, ids []int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Coffee.coffee":
		if e.complexity.Coffee.Coffee == nil {
			break
		}

		return e.complexity.Coffee.Coffee(childComplexity), true

	case "Coffee.coffeeMate":
		if e.complexity.Coffee.CoffeeMate == nil {
			break
		}

		return e.complexity.Coffee.CoffeeMate(childComplexity), true

	case "Coffee.id":
		if e.complexity.Coffee.ID == nil {
			break
		}

		return e.complexity.Coffee.ID(childComplexity), true

	case "Coffee.milk":
		if e.complexity.Coffee.Milk == nil {
			break
		}

		return e.complexity.Coffee.Milk(childComplexity), true

	case "Coffee.powderedMilk":
		if e.complexity.Coffee.PowderedMilk == nil {
			break
		}

		return e.complexity.Coffee.PowderedMilk(childComplexity), true

	case "Coffee.rating":
		if e.complexity.Coffee.Rating == nil {
			break
		}

		return e.complexity.Coffee.Rating(childComplexity), true

	case "Coffee.sugar":
		if e.complexity.Coffee.Sugar == nil {
			break
		}

		return e.complexity.Coffee.Sugar(childComplexity), true

	case "Coffee.water":
		if e.complexity.Coffee.Water == nil {
			break
		}

		return e.complexity.Coffee.Water(childComplexity), true

	case "CoffeeConnection.edges":
		if e.complexity.CoffeeConnection.Edges == nil {
			break
		}

		return e.complexity.CoffeeConnection.Edges(childComplexity), true

	case "CoffeeConnection.pageInfo":
		if e.complexity.CoffeeConnection.PageInfo == nil {
			break
		}

		return e.complexity.CoffeeConnection.PageInfo(childComplexity), true

	case "CoffeeConnection.totalCount":
		if e.complexity.CoffeeConnection.TotalCount == nil {
			break
		}

		return e.complexity.CoffeeConnection.TotalCount(childComplexity), true

	case "CoffeeEdge.cursor":
		if e.complexity.CoffeeEdge.Cursor == nil {
			break
		}

		return e.complexity.CoffeeEdge.Cursor(childComplexity), true

	case "CoffeeEdge.node":
		if e.complexity.CoffeeEdge.Node == nil {
			break
		}

		return e.complexity.CoffeeEdge.Node(childComplexity), true

	case "Mutation.createCoffee":
		if e.complexity.Mutation.CreateCoffee == nil {
			break
		}

		args, err := ec.field_Mutation_createCoffee_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCoffee(childComplexity, args["input"].(ent.CreateCoffeeInput)), true

	case "Mutation.deleteCoffee":
		if e.complexity.Mutation.DeleteCoffee == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCoffee_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCoffee(childComplexity, args["id"].(int)), true

	case "Mutation.updateCoffee":
		if e.complexity.Mutation.UpdateCoffee == nil {
			break
		}

		args, err := ec.field_Mutation_updateCoffee_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCoffee(childComplexity, args["id"].(int), args["input"].(ent.UpdateCoffeeInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.coffees":
		if e.complexity.Query.Coffees == nil {
			break
		}

		args, err := ec.field_Query_coffees_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Coffees(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateCoffeeInput,
		ec.unmarshalInputUpdateCoffeeInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "gql/coffee.graphql", Input: `type Mutation {
    # The input and the output are types generated by Ent.
    createCoffee(input: CreateCoffeeInput!): Coffee
    deleteCoffee(id: ID!): ID
    updateCoffee(id: ID!, input: UpdateCoffeeInput!): Coffee
}`, BuiltIn: false},
	{Name: "gql/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Coffee implements Node {
  id: ID!
  sugar: Int!
  coffee: Int!
  powderedMilk: Int!
  coffeeMate: Int!
  milk: Int!
  water: Int!
  rating: Float!
}
"""A connection to a list of items."""
type CoffeeConnection {
  """A list of edges."""
  edges: [CoffeeEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type CoffeeEdge {
  """The item at the end of the edge."""
  node: Coffee
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
CreateCoffeeInput is used for create Coffee object.
Input was generated by ent.
"""
input CreateCoffeeInput {
  sugar: Int!
  coffee: Int!
  powderedMilk: Int!
  coffeeMate: Int!
  milk: Int!
  water: Int!
  rating: Float!
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "main/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  coffees(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CoffeeConnection!
}
"""
UpdateCoffeeInput is used for update Coffee object.
Input was generated by ent.
"""
input UpdateCoffeeInput {
  sugar: Int
  coffee: Int
  powderedMilk: Int
  coffeeMate: Int
  milk: Int
  water: Int
  rating: Float
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
